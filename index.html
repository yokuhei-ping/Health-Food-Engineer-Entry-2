<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ä¿å¥é£Ÿå“åˆç´šå·¥ç¨‹å¸«ï½œæ­·å±†è©¦é¡Œç·šä¸Šç·´ç¿’ï¼ˆå«æ˜Ÿæ˜Ÿç†Ÿæ‚‰åº¦ï¼‰</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="bg-gray-50">
    <div id="root"></div>
    <noscript>æœ¬é éœ€è¦å•Ÿç”¨ JavaScript æ‰èƒ½ä½¿ç”¨ã€‚</noscript>

    <!-- å¿…è¦å‡½å¼åº« -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

   <script type="text/babel" data-presets="env,react">
  const { useState, useEffect, useMemo, useRef } = React;

  const LS_KEY  = "hf-beginner-exam-app-v1";
  const LS_STAR = "hf-beginner-exam-stars-v1";
  const LS_RUN  = "hf-beginner-exam-run-v1";

  const serialize = (d)=>JSON.stringify(d);
  const deserialize = (s)=> (s?JSON.parse(s):null);
  const deBOM = (s)=> (typeof s==="string"? s.replace(/^\uFEFF/, ""): s);

  const normalizeKeys=(raw)=>{
    const out={};
    Object.entries(raw||{}).forEach(([k,v])=>{
      const nk = deBOM(String(k)).trim();
      out[nk]=v;
    });
    return out;
  };
  const pick=(obj,keys)=>{
    for(const k of keys){ if(obj[k]!=null && obj[k]!=="" ) return obj[k]; }
    return undefined;
  };
  const shuffle=(arr)=>{
    const a=[...arr];
    for(let i=a.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  };
  const fmtTime=(s)=>{
    const mm = Math.floor(s/60).toString().padStart(2,"0");
    const ss = Math.floor(s%60).toString().padStart(2,"0");
    return `${mm}:${ss}`;
  };

  // è½‰æ› CSV åˆ—ç‚ºé¡Œç›®ç‰©ä»¶
  const rowToQA=(row)=>{
    const r=normalizeKeys(row);
    const year=(pick(r,["year","å¹´åº¦","å¹´ä»½"])??"").toString().trim();
    const subject=(pick(r,["subject","ç§‘ç›®"])??"").toString().trim();
    const question_no=(pick(r,["question_no","é¡Œè™Ÿ","é¡Œç›®ç·¨è™Ÿ","no","id"])??"").toString().trim();
    const question=(pick(r,["question","é¡Œç›®","stem"])??"").toString().trim();
    const option_A=(pick(r,["option_A","A","é¸é …A"])??"").toString();
    const option_B=(pick(r,["option_B","B","é¸é …B"])??"").toString();
    const option_C=(pick(r,["option_C","C","é¸é …C"])??"").toString();
    const option_D=(pick(r,["option_D","D","é¸é …D"])??"").toString();
    const correct_answers=(pick(r,["correct_answers","æ­£ç¢ºç­”æ¡ˆ","answer"])??"").toString().replace(/\s/g,"");
    const notes=(pick(r,["notes","å‚™è¨»"])??"").toString();
    const date=(pick(r,["date","æ—¥æœŸ"])??"").toString();
    const session=(pick(r,["session","å ´æ¬¡"])??"").toString().trim();
    const salt=(date || session || (question? question.slice(0,20).replace(/\s+/g,""):""));
    const id=`${year}-${salt}-${subject}-${question_no}`;
    const options=["A","B","C","D"].map(k=>({key:k, text:(k==="A"?option_A:k==="B"?option_B:k==="C"?option_C:option_D).trim()}));
    return { id,year,date,subject,question_no,question,option_A,option_B,option_C,option_D,options,correct_answers,notes };
  };

// gh:owner/repo@ref:path æˆ– github.com/.../blob/... â†’ raw ä¸‹è¼‰é€£çµ
const resolveGhUrl = (s) => {
  if (!s) return s;

  // æ”¯æ´ gh: çŸ­ç¶²å€
  if (s.startsWith("gh:")) {
    const body = s.slice(3);
    const [repoPart, path] = body.split(":");
    const [ownerRepo, ref] = repoPart.split("@");
    const [owner, repo] = ownerRepo.split("/");
    return `https://raw.githubusercontent.com/${owner}/${repo}/${ref}/${encodeURI(path)}`;
  }

  // æ”¯æ´ github.com çš„ blob é é¢
  try {
    const u = new URL(s);
    if (u.hostname === "github.com") {
      // /owner/repo/blob/ref/path/...
      const parts = u.pathname.split("/").filter(Boolean);
      const idx = parts.indexOf("blob");
      if (idx >= 2) {
        const owner = parts[0];
        const repo  = parts[1];
        const ref   = parts[idx + 1];
        const path  = parts.slice(idx + 2).join("/");
        return `https://raw.githubusercontent.com/${owner}/${repo}/${ref}/${path}`;
      }
    }
  } catch (_) {}

  return s;
};




     
  const StarBar=({value=0,size=18})=>{
    const full=Math.max(0,Math.min(5,Number(value)||0));
    return (
      <div className="inline-flex items-center" title={`ç†Ÿæ‚‰åº¦ï¼š${full} é¡†æ˜Ÿ`}>
        {Array.from({length:5}).map((_,i)=>(
          <svg key={i} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width={size} height={size}
               className={i<full?"fill-yellow-400 text-yellow-400":"fill-none text-gray-300"}
               stroke="currentColor" strokeWidth="2">
            <path d="M12 17.27 18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/>
          </svg>
        ))}
      </div>
    );
  };

  function App(){
    const [bank,setBank]=useState([]);
    const [subject,setSubject]=useState("å…¨éƒ¨ç§‘ç›®");
    const [year,setYear]=useState("å…¨éƒ¨å¹´åº¦");
    const [mode,setMode]=useState("practice"); // practice | exam
    const [limit,setLimit]=useState(40);
    const [page,setPage]=useState(0);
    const [answers,setAnswers]=useState({});
    const [started,setStarted]=useState(false);
    const [seed,setSeed]=useState(0);
    const [seconds,setSeconds]=useState(0);
    const timerRef=useRef(null);

    // å‡çµè€ƒå·
    const [frozenPaperIds,setFrozenPaperIds]=useState(null);

    // æ˜Ÿæ˜Ÿ
    const [stars,setStars]=useState({});
    const [maxStarFilter,setMaxStarFilter]=useState(null); // null=å…¨éƒ¨ï¼›0..5 = â‰¤N

    // é¡Œåº«è¼‰å…¥ï¼ˆæœ¬æ©Ÿ or URLï¼‰
    const [csvUrl, setCsvUrl] = useState("gh:yokuhei-ping/Health-Food-Engineer-Entry@b18caf88dce70271f4e51f25c0931fa0efbbed39:Question_All_corrected.csv");

    const bootLoadedRef=useRef(false);

    // ---- åˆå§‹åŒ– / æŒä¹…åŒ– ----
    useEffect(()=>{
      const saved=deserialize(localStorage.getItem(LS_KEY));
      if(saved){
        setBank(saved.bank||[]);
        setSubject(saved.subject||"å…¨éƒ¨ç§‘ç›®");
        setYear(saved.year||"å…¨éƒ¨å¹´åº¦");
        setMode(saved.mode||"practice");
      }
      const s=deserialize(localStorage.getItem(LS_STAR)); if(s) setStars(s);
      const run=deserialize(localStorage.getItem(LS_RUN));
      if(run){
        setStarted(!!run.started);
        setAnswers(run.answers||{});
        setPage(run.page||0);
        setFrozenPaperIds(run.frozenPaperIds||null);
        setSeed(run.seed||0);
        setLimit(run.limit||40);
        setMode(run.mode||"practice");
        setSubject(run.subject||"å…¨éƒ¨ç§‘ç›®");
        setYear(run.year||"å…¨éƒ¨å¹´åº¦");
        if(run.maxStarFilter!=null) setMaxStarFilter(run.maxStarFilter);
      }
    },[]);

    // å¦‚æœä¸€é–‹å§‹ bank ç‚ºç©ºï¼Œå˜—è©¦ç”¨é è¨­ URL è¼‰å…¥ä¸€æ¬¡
    useEffect(()=>{
      if(bootLoadedRef.current) return;
      if(bank.length===0 && csvUrl){
        bootLoadedRef.current=true;
        loadFromUrl(csvUrl);
      }
    },[bank.length,csvUrl]);

    useEffect(()=>{ localStorage.setItem(LS_KEY, serialize({bank,subject,year,mode})); },[bank,subject,year,mode]);
    useEffect(()=>{ localStorage.setItem(LS_STAR, serialize(stars)); },[stars]);
    useEffect(()=>{ localStorage.setItem(LS_RUN, serialize({started,answers,page,frozenPaperIds,seed,limit,mode,subject,year,maxStarFilter})); },
      [started,answers,page,frozenPaperIds,seed,limit,mode,subject,year,maxStarFilter]);

    // ---- å°å‡ºå¹´åº¦/ç§‘ç›®æ¸…å–® ----
    const subjectList=useMemo(()=>{
      const s=new Set(bank.map(q=>q.subject).filter(Boolean));
      return ["å…¨éƒ¨ç§‘ç›®",...Array.from(s)];
    },[bank]);
    const yearList=useMemo(()=>{
      const s=new Set(bank.map(q=>String(q.year)).filter(Boolean));
      return ["å…¨éƒ¨å¹´åº¦",...Array.from(s).sort((a,b)=>b.localeCompare(a))];
    },[bank]);

    // ---- ç¯©é¸ & å‡ºå·ï¼ˆæ”¯æ´å‡çµï¼‰----
    const filtered=useMemo(()=> bank.filter(q=>{
      const okS = subject==="å…¨éƒ¨ç§‘ç›®" || q.subject===subject;
      const okY = year==="å…¨éƒ¨å¹´åº¦"   || String(q.year)===year;
      const st  = Number(stars[q.id]||0);
      const okStar = (maxStarFilter==null) || st<=maxStarFilter;
      return okS && okY && okStar;
    }),[bank,subject,year,stars,maxStarFilter]);
      
      const paper = useMemo(() => {
        if (started && Array.isArray(frozenPaperIds) && frozenPaperIds.length) {
          const byId = new Map(bank.map(q => [q.id, q]));
          return frozenPaperIds.map(id => byId.get(id)).filter(Boolean);
        }
        const base = shuffle(filtered.slice());
        return base.slice(0, Math.min(limit, base.length));
      }, [bank, filtered, limit, started, frozenPaperIds, seed]);
      

    // ---- è¨ˆæ™‚ï¼ˆæ¨¡æ“¬æ¸¬é©—ï¼‰----
    useEffect(()=>{
      if(!started || mode!=="exam") return;
      timerRef.current=setInterval(()=>setSeconds(s=>s+1),1000);
      return ()=>clearInterval(timerRef.current);
    },[started,mode]);

    // ---- ä½œç­” & æ˜Ÿæ˜Ÿè¦å‰‡ ----
    const current=paper[page];
    const choose=(qid,key)=>setAnswers(prev=>({...prev,[qid]:key}));
    const correctSetOf=(q)=> (q.correct_answers||"").split(",").map(x=>x.trim()).filter(Boolean);
    const isCorrect=(q,user)=> user ? correctSetOf(q).includes(user) : false;
    const currentId = current?.id;
    const pickedForCurrent = currentId ? answers[currentId] : undefined;
    
    useEffect(() => {
      if (!currentId || !pickedForCurrent) return;
      const correct = isCorrect(current, pickedForCurrent);
      setStars(prev => {
        const cur  = Number(prev[currentId] || 0);
        const next = correct ? Math.min(5, cur + 1) : 0;
        return next === cur ? prev : { ...prev, [currentId]: next };
      });
    }, [currentId, pickedForCurrent]);

    // âœ… ç•¶ paper é•·åº¦è®ŠåŒ–æ™‚ï¼Œè‡ªå‹•æŠŠ page å¤¾åœ¨åˆæ³•ç¯„åœå…§
    useEffect(() => {
      setPage(p => {
        if (!paper.length) return 0;
        return Math.min(Math.max(p, 0), paper.length - 1);
      });
    }, [paper.length]);

    // ---- çµ±è¨ˆ ----
    const score=useMemo(()=>{
      let right=0; paper.forEach(q=>{ if(isCorrect(q,answers[q.id])) right++; });
      return {right,total:paper.length};
    },[paper,answers]);
    const answeredCount=useMemo(()=>{
      const set=new Set(paper.map(q=>q.id));
      let n=0; for(const [qid,v] of Object.entries(answers)){ if(set.has(qid)&&v) n++; }
      return n;
    },[paper,answers]);
    const progressPct=useMemo(()=> paper.length? Math.round(answeredCount/paper.length*100):0,[answeredCount,paper.length]);

    // ---- å‡ºå·/äº¤å· ----
    const start=()=>{
      const ids=shuffle(filtered.slice()).slice(0,Math.min(limit,filtered.length)).map(q=>q.id);
      setFrozenPaperIds(ids);
      setAnswers({}); setPage(0); setSeed(s=>s+1); setSeconds(0); setStarted(true);
    };
    const stop=()=>{ setStarted(false); if(timerRef.current) clearInterval(timerRef.current); };

    // ---- åŒ¯å‡ºéŒ¯é¡Œæœ¬ CSV ----
    const exportWrongCsv=()=>{
      // ä»¥ç›®å‰ä½œç­”ç´€éŒ„ç‚ºæº–ï¼ˆæœ¬æ¬¡è€ƒå·æˆ–æ­·æ¬¡ç•™å­˜çš„ answersï¼‰
      const byId=new Map(bank.map(q=>[q.id,q]));
      const rows=[];
      for(const [qid,ua] of Object.entries(answers||{})){
        const q=byId.get(qid);
        if(!q || !ua) continue;
        const ok=correctSetOf(q);
        const isRight=ok.includes(ua);
        if(isRight) continue; // åªæ”¶éŒ¯é¡Œ
        rows.push({
          year: q.year, subject: q.subject, question_no: q.question_no,
          question: q.question, option_A: q.option_A, option_B: q.option_B,
          option_C: q.option_C, option_D: q.option_D,
          correct_answers: q.correct_answers, user_answer: ua,
          notes: q.notes ?? ""
        });
      }
      if(rows.length===0){ alert("ç›®å‰æ²’æœ‰éŒ¯é¡Œå¯ä»¥åŒ¯å‡ºï½ (à¹‘â€¢Ì€ã…‚â€¢Ì)Ùˆâœ§"); return; }
      const csv = Papa.unparse(rows);
      const blob = new Blob([csv], { type:"text/csv;charset=utf-8" });
      saveAs(blob, "wrong_notes.csv");
    };

    // ---- æ¸…ç©ºé¡Œåº«ï¼ˆåƒ…æ¸… bankï¼‰----
    const clearBank=()=>{
      if(!confirm("ç¢ºå®šæ¸…ç©ºé¡Œåº«ï¼Ÿï¼ˆåƒ…åˆªé™¤é¡Œåº«å…§å®¹ï¼Œå…¶ä»–ç‹€æ…‹ä¿ç•™ï¼‰")) return;
      setBank([]);
      // é¡å¤–æŠŠå‡çµè€ƒå·è§£é™¤ï¼Œé¿å…æ®˜ç•™å¼•ç”¨
      setFrozenPaperIds(null);
      setStarted(false);
      setPage(0);
    };

    // ---- è¼‰å…¥ CSV ----
    const loadFromFile=(file)=>{
      if(!file) return;
      Papa.parse(file, {
        header:true, skipEmptyLines:true, encoding:"UTF-8",
        complete:(res)=>{
          const rows=res.data||[];
          const items=rows.map(rowToQA).filter(x=>x.id && x.question);
          setBank(items);
        },
        error:(e)=>alert("åŒ¯å…¥å¤±æ•—ï¼š"+e.message)
      });
    };
      async function loadFromUrl(urlStr){
    try{
      const url = resolveGhUrl((urlStr || csvUrl).trim());
      const resp = await fetch(url, { cache: "no-store" });
      if (!resp.ok) throw new Error(`${resp.status} ${resp.statusText}`);
      const text = await resp.text();
      Papa.parse(text,{
        header:true, skipEmptyLines:true,
        complete:(res)=>{
          const rows  = res.data || [];
          const items = rows.map(rowToQA).filter(x=>x.id && x.question);
          setBank(items);
        },
        error:(e)=>alert("è§£æå¤±æ•—ï¼š"+e.message)
      });
    }catch(err){
      alert("ä¸‹è¼‰å¤±æ•—ï¼š"+(err?.message||err));
    }
  }


    // ---- UI ----
    const correctColor=(picked,isRight)=> {
      return (mode==="practice")
        ? (picked ? (isRight ? "bg-green-50 border-green-400" : "bg-red-50 border-red-400") : "")
        : (picked ? "bg-blue-50 border-blue-400" : "");
    };
    // âœ… æ›é¡Œåªçœ‹é‚Šç•Œï¼Œä¸å—ç­”å°/ç­”éŒ¯å½±éŸ¿
    const goPrev = () => setPage(p => (p > 0 ? p - 1 : 0));
    const goNext = () => setPage(p => (p < paper.length - 1 ? p + 1 : p));

    return (
      <div className="p-6">
        <h1 className="font-bold text-xl mb-3">ä¿å¥é£Ÿå“åˆç´šå·¥ç¨‹å¸«ï½œæ­·å±†è©¦é¡Œç·šä¸Šç·´ç¿’ï¼ˆå«æ˜Ÿæ˜Ÿç†Ÿæ‚‰åº¦ï¼‰</h1>

        {/* è‹¥é¡Œåº«ç‚ºç©ºï¼Œé¡¯ç¤ºè¼‰å…¥æ§ä»¶ */}
        {bank.length===0 && (
          <div className="mb-4 p-4 bg-amber-50 border border-amber-300 rounded">
            <div className="mb-2">ç›®å‰é¡Œåº«ç‚ºç©ºï¼Œè«‹ä»¥ä»¥ä¸‹ä»»ä¸€æ–¹å¼è¼‰å…¥ï¼š</div>
            <div className="flex flex-col sm:flex-row gap-2 items-start">
              <label className="text-sm">
                æœ¬æ©Ÿ CSVï¼š
                <input type="file" accept=".csv" className="ml-2" onChange={e=>loadFromFile(e.target.files[0])}/>
              </label>
              <div className="flex gap-2 items-center">
                <input className="border rounded px-2 py-1 w-96" placeholder="è²¼ä¸Š CSV é€£çµï¼ˆå¯ç”¨ gh: çŸ­ç¶²å€ï¼‰"
                       value={csvUrl} onChange={e=>setCsvUrl(e.target.value)} />
                <button className="border rounded px-3 py-1" onClick={()=>loadFromUrl(csvUrl)}>å¾é€£çµè¼‰å…¥</button>
              </div>
            </div>
          </div>
        )}

        {/* æ§åˆ¶åˆ— */}
        <div className="flex flex-wrap items-center gap-3 mb-4">
          {/* æ¨¡å¼ */}
          <div className="inline-flex rounded-lg overflow-hidden border">
            <button className={`px-3 py-1 ${mode==='practice'?'bg-blue-600 text-white':'bg-white'}`} onClick={()=>setMode('practice')}>ç·´ç¿’æ¨¡å¼</button>
            <button className={`px-3 py-1 ${mode==='exam'?'bg-blue-600 text-white':'bg-white'}`} onClick={()=>setMode('exam')}>æ¨¡æ“¬æ¸¬é©—</button>
          </div>
       {/* é¡Œåº«çµ±è¨ˆ */}
          <div className="mb-3 text-sm text-gray-600">
            ç›®å‰é¡Œåº«ï¼š{filtered.length} é¡Œï¼ˆç¬¦åˆç¯©é¸ï¼‰ï¼ å…¨éƒ¨ {bank.length} é¡Œ
          </div>

          {/* å¹´åº¦/ç§‘ç›® */}
          <select className="border rounded px-2 py-1" value={year} onChange={e=>setYear(e.target.value)}>
            {yearList.map(y=><option key={y} value={y}>{y}</option>)}
          </select>
          <select className="border rounded px-2 py-1" value={subject} onChange={e=>setSubject(e.target.value)}>
            {subjectList.map(s=><option key={s} value={s}>{s}</option>)}
          </select>

          {/* é¡Œæ•¸ä¸Šé™ */}
          <label className="text-sm text-gray-600">å‡ºé¡Œæ•¸ï¼š
            <input type="number" min="1" className="ml-1 w-20 border rounded px-2 py-1"
                   value={limit} onChange={e=>setLimit(Number(e.target.value)||1)} />
          </label>

          {/* æ˜Ÿæ˜Ÿç¯©é¸ */}
          <div className="flex items-center gap-1">
            <span className="text-sm">æ˜Ÿæ˜Ÿâ‰¤</span>
            {[-1,0,1,2,3,4,5].map(v=>(
              <button key={v}
                className={`text-sm border rounded px-2 py-1 ${maxStarFilter===(v<0?null:v)?'bg-amber-200':'bg-white'}`}
                onClick={()=>setMaxStarFilter(v<0?null:v)}>
                {v<0?'å…¨éƒ¨':v}
              </button>
            ))}
          </div>

          {/* åŠŸèƒ½ï¼šåŒ¯å‡ºéŒ¯é¡Œæœ¬ã€æ¸…ç©ºé¡Œåº« */}
          <button className="border rounded px-3 py-1" onClick={exportWrongCsv}>åŒ¯å‡ºéŒ¯é¡Œæœ¬ CSV</button>
          <button className="border rounded px-3 py-1" onClick={clearBank}>æ¸…ç©ºé¡Œåº«</button>

          {/* é–‹å§‹/çµæŸ */}
          <div className="ml-auto">
            {!started
              ? <button className="border px-3 py-1 rounded bg-green-600 text-white" onClick={start}>é–‹å§‹ä½œç­”</button>
              : <button className="border px-3 py-1 rounded bg-red-600 text-white" onClick={stop}>çµæŸ/äº¤å·</button>}
          </div>
        </div>

        {/* é€²åº¦åˆ— */}
        {started && (
          <div className="mb-3">
            <div className="flex items-center justify-between text-sm mb-1">
              <div>ä½œç­”é€²åº¦ï¼š{answeredCount}/{paper.length} é¡Œï¼ˆ{progressPct}%ï¼‰</div>
              <div>ç›®å‰çµ±è¨ˆï¼š<span className="font-semibold">{score.right}</span>/<span>{score.total}</span> é¡Œ æ­£ç¢º</div>
              {mode==="exam" && <div className="font-mono">è¨ˆæ™‚ï¼š{fmtTime(seconds)}</div>}
            </div>
            <div className="w-full h-2 bg-gray-200 rounded">
              <div className="h-2 bg-blue-500 rounded" style={{width:`${progressPct}%`}}/>
            </div>
          </div>
        )}

        {/* é¡Œç›® */}
        {started && paper.length>0 && (
          <div className="bg-white shadow rounded p-4">
            <div className="text-sm mb-2 flex items-center justify-between">
              <div>ç¬¬ {page+1}/{paper.length} é¡Œ</div>
              <StarBar value={Number(stars[paper[page].id]||0)} />
            </div>
         

{/* ğŸ†• é¡Œç›®ä¸­ç¹¼è³‡æ–™åˆ—ï¼šç§‘ç›®ï¼å¹´åº¦ï¼é¡Œè™Ÿ */}
<div className="flex flex-wrap items-center gap-2 mb-3">
  <span className="px-2 py-0.5 text-xs rounded-full bg-blue-50 text-blue-700 border border-blue-200">
    {mode === "exam" ? "æ¨¡æ“¬" : "ç·´ç¿’"}
  </span>

  {paper[page].subject && (
    <span className="px-2 py-0.5 text-xs rounded-full bg-gray-100 text-gray-800 border border-gray-200">
      {paper[page].subject}
    </span>
  )}

  {paper[page].year && (
    <span className="px-2 py-0.5 text-xs rounded-full bg-gray-100 text-gray-800 border border-gray-200">
      {paper[page].year} å¹´
    </span>
  )}

  {paper[page].question_no && (
    <span className="px-2 py-0.5 text-xs rounded-full bg-gray-100 text-gray-800 border border-gray-200">
      é¡Œè™Ÿï¼š{paper[page].question_no}
    </span>
  )}
</div>



            <h2 className="mb-3">{paper[page].question}</h2>

            <ul className="mb-3">
              {paper[page].options.map(op=>{
                const picked=answers[paper[page].id]===op.key;
                const isRight=correctSetOf(paper[page]).includes(op.key);
                return (
                  <li key={op.key}>
                    <button
                      onClick={()=>choose(paper[page].id,op.key)}
                      className={`border block w-full text-left rounded px-3 py-2 mb-2 ${correctColor(picked,isRight)}`}>
                      <span className="font-mono mr-2">({op.key})</span>{op.text}
                    </button>
                  </li>
                );
              })}
            </ul>

                       <div className="mt-2 flex gap-2">
              <button
                type="button"
                className="border rounded px-3 py-1"
                disabled={page === 0}
                onClick={goPrev}
              >
                ä¸Šä¸€é¡Œ
              </button>
              <button
                type="button"
                className="border rounded px-3 py-1"
                disabled={page >= paper.length - 1}
                onClick={goNext}
              >
                ä¸‹ä¸€é¡Œ
              </button>
            </div>


            {mode==="practice" && answers[paper[page].id] && (
              <div className="mt-3 border-t pt-3 text-sm">
                æ­£ç¢ºç­”æ¡ˆï¼š<span className="font-bold text-green-700">{correctSetOf(paper[page]).join("ã€")||"ï¼ˆæœªæä¾›ï¼‰"}</span>
              </div>
            )}
          </div>
        )}

        {/* é¡Œç›®æ¸…å–®å¿«é€Ÿè·³è½‰ */}
        {started && paper.length>0 && (
          <div className="mt-4">
            <div className="text-sm text-gray-600 mb-2">é¡Œç›®æ¸…å–®ï¼ˆé»æ“Šå¯è·³è½‰ï¼‰ï¼š</div>
            <div className="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-2">
              {paper.map((q,idx)=>{
                const picked=!!answers[q.id];
                const right=isCorrect(q,answers[q.id]);
                const color=picked?(right?"bg-green-50 border-green-400":"bg-red-50 border-red-400"):"bg-white";
                return (
                  <button key={q.id}
                          className={`border rounded px-2 py-1 text-sm flex items-center justify-between ${color}`}
                          onClick={()=>setPage(idx)} title={`ç¬¬ ${idx+1} é¡Œ`}>
                    <span className="font-mono">#{idx+1}</span>
                    <StarBar value={Number(stars[q.id]||0)} size={14}/>
                  </button>
                );
              })}
            </div>
          </div>
        )}
      </div>
    );
  }

  const root = ReactDOM.createRoot(document.getElementById("root"));
  root.render(<App/>);
</script>


  </body>
</html>
