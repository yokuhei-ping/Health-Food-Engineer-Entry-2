<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ä¿å¥é£Ÿå“åˆç´šå·¥ç¨‹å¸«ï½œæ­·å±†è©¦é¡Œç·šä¸Šç·´ç¿’ï¼ˆå«æ˜Ÿæ˜Ÿç†Ÿæ‚‰åº¦ï¼‰</title>
    <!-- Tailwindï¼ˆCDNï¼‰è®“æ¨£å¼çœ‹èµ·ä¾†æ¥è¿‘ä½ åŸæœ¬è¨­è¨ˆ -->
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="bg-gray-50">
    <div id="root"></div>
    <noscript>æœ¬é éœ€è¦å•Ÿç”¨ JavaScript æ‰èƒ½ä½¿ç”¨ã€‚</noscript>

    <!-- å¿…è¦å‡½å¼åº«ï¼ˆCDNï¼‰ -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

    <script type="text/babel" data-presets="env,react">
      const { useState, useEffect, useMemo, useRef } = React;
      const PapaLib = window.Papa; // Papaparse (CDN)
      const FileSaver = window.FileSaver || { saveAs: window.saveAs }; // FileSaver (CDN)

      // ==== å°å·¥å…· ====
      const LS_KEY = "hf-beginner-exam-app-v1";
      const LS_STAR = "hf-beginner-exam-stars-v1"; // â­ æ¯é¡Œ 0~5 ç†Ÿæ‚‰åº¦
      const serialize = (data) => JSON.stringify(data);
      const deserialize = (s) => (s ? JSON.parse(s) : null);
      const deBOM = (s) => (typeof s === "string" ? s.replace(/^\uFEFF/, "") : s);
      const normalizeKeys = (raw) => {
        const out = {};
        Object.entries(raw || {}).forEach(([k, v]) => {
          const nk = deBOM(String(k)).trim();
          out[nk] = v;
        });
        return out;
      };
      const pick = (obj, keys) => {
        for (const k of keys) {
          if (obj[k] != null && obj[k] !== "") return obj[k];
        }
        return undefined;
      };
      const shuffle = (arr) => {
        const copy = [...arr];
        for (let i = copy.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [copy[i], copy[j]] = [copy[j], copy[i]];
        }
        return copy;
      };
      const fmtTime = (s) => {
        const mm = Math.floor(s / 60).toString().padStart(2, "0");
        const ss = Math.floor(s % 60).toString().padStart(2, "0");
        return `${mm}:${ss}`;
      };

      // ==== å‹åˆ¥èªªæ˜ï¼ˆè¨»è§£ï¼‰====
      // Correction: { å¹´åº¦: string, å ´æ¬¡?: string, ç§‘ç›®: string, é¡Œè™Ÿ: number, æ­£ç¢ºç­”æ¡ˆ: string }
      // QA: { id, year, date, subject, question_no, question, option_A..D, options[], correct_answers, notes }

      const rowToQA = (row) => {
        const r = normalizeKeys(row);
        const year = (pick(r, ["year", "å¹´åº¦", "å¹´ä»½"]) ?? "").toString().trim();
        const subject = (pick(r, ["subject", "ç§‘ç›®"]) ?? "").toString().trim();
        const question_no = (pick(r, ["question_no", "é¡Œè™Ÿ", "é¡Œç›®ç·¨è™Ÿ", "no", "id"]) ?? "").toString().trim();
        const question = (pick(r, ["question", "é¡Œç›®", "stem"]) ?? "").toString().trim();
        const option_A = (pick(r, ["option_A", "A", "é¸é …A"]) ?? "").toString();
        const option_B = (pick(r, ["option_B", "B", "é¸é …B"]) ?? "").toString();
        const option_C = (pick(r, ["option_C", "C", "é¸é …C"]) ?? "").toString();
        const option_D = (pick(r, ["option_D", "D", "é¸é …D"]) ?? "").toString();
        const correct_answers = (pick(r, ["correct_answers", "æ­£ç¢ºç­”æ¡ˆ", "answer"]) ?? "").toString().replace(/\s/g, "");
        const notes = (pick(r, ["notes", "å‚™è¨»"]) ?? "").toString();
        const date = (pick(r, ["date", "æ—¥æœŸ"]) ?? "").toString();
        const session = (pick(r, ["session", "å ´æ¬¡"]) ?? "").toString().trim();
        // è®“ä¸åŒå ´æ¬¡/æ—¥æœŸçš„åŒå¹´åŒç§‘ç›®åŒé¡Œè™Ÿä¸æœƒè¢«ç•¶æˆé‡è¤‡é¡Œè€Œåˆä½µ
        const salt = (date || session || (question ? String(question).slice(0, 20).replace(/\s+/g, "") : ""));
        const id = `${year || ""}-${salt}-${subject || ""}-${question_no || ""}`;
        const opts = ["A", "B", "C", "D"].map((k) => ({
          key: k,
          text: (
            pick(
              { option_A, option_B, option_C, option_D },
              [k === "A" ? "option_A" : k === "B" ? "option_B" : k === "C" ? "option_C" : "option_D"]
            ) || ""
          )
            .toString()
            .trim(),
        }));
        return { id, year, date, subject, question_no, question, option_A, option_B, option_C, option_D, options: opts, correct_answers, notes };
      };

      const safeSaveAs = (blob, filename) => {
        try {
          const fn = (FileSaver && (FileSaver.saveAs || FileSaver.default)) || window.saveAs;
          if (typeof fn === "function") { fn(blob, filename); return; }
        } catch (e) {}
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      };

      const exportCSV = (rows, filename = "export.csv") => {
        const csv = PapaLib.unparse(rows);
        const blob = new Blob(["\uFEFF" + csv], { type: "text/csv;charset=utf-8;" });
        safeSaveAs(blob, filename);
      };

      const SAMPLE_ROWS = [
        { year: 114, date: "2025-04-19", subject: "é£Ÿå“ç§‘å­¸æ¦‚è«–", question_no: 27, question: "ä¸‹åˆ—ä½•è€…ä¸æ˜¯é£Ÿå“æ·»åŠ ç‰©çš„ã€æ®ºèŒåŠ‘ã€‘ï¼Ÿ", option_A: "é…¸åŒ–äºç¡«é…¸éˆ‰", option_B: "æ¬¡æ°¯é…¸", option_C: "é¹½é…¸", option_D: "éæ°§åŒ–æ°«", correct_answers: "A,B,C", notes: "å®˜æ–¹å…¬å‘Šï¼šA/B/C çš†çµ¦åˆ†ï¼ˆ114/4/19 ç¬¬äºŒç§‘ï¼‰" },
        { year: 114, date: "2025-04-19", subject: "ä¿å¥é£Ÿå“æ¦‚è«–", question_no: 25, question: "å¥åº·é£Ÿå“ç”¢å“é…æ–¹ä¾æ¯æ—¥å»ºè­°æ”å–é‡ï¼Œæ‰€å«ä¹‹å¤–åŠ ç²¾ç·»ç³–ä¹‹é™é‡ç‚ºä½•ï¼Ÿ", option_A: "50 å…¬å…‹", option_B: "25 å…¬å…‹", option_C: "17 å…¬å…‹", option_D: "10 å…¬å…‹", correct_answers: "C", notes: "å®˜æ–¹å…¬å‘Šï¼šç­”æ¡ˆæ›´æ­£ç‚º(C)ï¼ˆ114/4/19 ç¬¬ä¸€ç§‘ï¼‰" },
        { year: 114, date: "2025-04-19", subject: "ä¿å¥é£Ÿå“æ¦‚è«–", question_no: 76, question: "ä¸‹åˆ—ä½•è€…ä¸æ˜¯ç¶­ç”Ÿç´  Bâ‚â‚‚ ç¼ºä¹å°è‡´æ‰€ä¼´éš¨ä¹‹è‡¨åºŠç—‡ç‹€ï¼Ÿ", option_A: "å·¨çƒæ€§è²§è¡€", option_B: "åŒåŠèƒ±èƒºé…¸è¡€ç—‡", option_C: "æƒ¡æ€§è²§è¡€", option_D: "å°çƒæ€§è²§è¡€", correct_answers: "A,B,C,D", notes: "å®˜æ–¹å…¬å‘Šï¼š(A)(B)(C)(D)çš†çµ¦åˆ†ï¼ˆ114/4/19 ç¬¬ä¸€ç§‘ï¼‰" },
        { year: 114, date: "2025-04-19", subject: "é£Ÿå“ç§‘å­¸æ¦‚è«–", question_no: 1, question: "æœ‰é—œé…µç´ çš„æ•˜è¿°ï¼Œä¸‹åˆ—ä½•è€…éŒ¯èª¤ï¼Ÿ", option_A: "å¯ç”¨æœ¨ç“œè›‹ç™½é…¶è»ŸåŒ–æ¬¡ç´šè‚‰", option_B: "å¤šç¨®é…µç´ å¯è£½é€ é«˜æœç³–ç³–æ¼¿", option_C: "0.1% é£Ÿé¹½æ°´å¯å®Œå…¨æŠ‘åˆ¶é…šé…¶è¤è®Š", option_D: "å‡ä¹³é…¶å¯æ‡‰ç”¨æ–¼ä¹³å“è£½æˆä¹¾é…ª", correct_answers: "C", notes: "ç¤ºç¯„é¡Œ" }
      ];

      const applyCorrectionsToBank = (bank, corrections) => {
        const idx = new Map();
        for (const c of corrections || []) {
          if (!c || !c.å¹´åº¦ || !c.ç§‘ç›® || !Number.isFinite(Number(c.é¡Œè™Ÿ))) continue;
          const key = `${String(c.å¹´åº¦)}-${c.ç§‘ç›®}-${Number(c.é¡Œè™Ÿ)}`;
          idx.set(key, (c.æ­£ç¢ºç­”æ¡ˆ || "").replace(/\s/g, ""));
        }
        return bank.map((q) => {
          const key = `${q.year || ""}-${q.subject || ""}-${q.question_no || ""}`;
          return idx.has(key) ? { ...q, correct_answers: idx.get(key) } : q;
        });
      };

      const ensureFileSelected = (file) => !!file;

      // â­ å°å…ƒä»¶ï¼šç•«æ˜Ÿæ˜Ÿï¼ˆ0~5ï¼‰
      const StarBar = ({ value = 0, size = 18 }) => {
        const full = Math.max(0, Math.min(5, Number(value) || 0));
        return (
          <div className="inline-flex items-center" title={`ç†Ÿæ‚‰åº¦ï¼š${full} é¡†æ˜Ÿ`}>
            {Array.from({ length: 5 }).map((_, i) => (
              <svg key={i} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width={size} height={size}
                   className={i < full ? "fill-yellow-400 text-yellow-400" : "fill-none text-gray-300"} stroke="currentColor" strokeWidth="2">
                <path d="M12 17.27 18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/>
              </svg>
            ))}
          </div>
        );
      };

      function App() {
        const [bank, setBank] = useState([]);
        const [subject, setSubject] = useState("å…¨éƒ¨ç§‘ç›®");
        const [year, setYear] = useState("å…¨éƒ¨å¹´åº¦");
        const [mode, setMode] = useState("practice"); // "practice" | "exam"
        const [limit, setLimit] = useState(40);
        const [page, setPage] = useState(0);
        const [answers, setAnswers] = useState({});
        const [started, setStarted] = useState(false);
        const [seed, setSeed] = useState(0);
        const [seconds, setSeconds] = useState(0);
        const timerRef = useRef(null);
        const [corrections, setCorrections] = useState([]);
        const [bankUrl, setBankUrl] = useState("gh:yokuhei-ping/Health-Food-Engineer-Entry@b18caf88dce70271f4e51f25c0931fa0efbbed39:Question_All_corrected.csv");
        const [corrUrl, setCorrUrl] = useState("https://github.com/PingYangtw/Health-Food-Engineer-Entry/blob/2e123d2ca94719de803cd8766b22256a37630c58/exam_corrections_all_years.csv");

        // â­ æ˜Ÿæ˜Ÿç†Ÿæ‚‰åº¦ç‹€æ…‹
        const [stars, setStars] = useState({}); // { [qid]: 0..5 }
        const [maxStarFilter, setMaxStarFilter] = useState(null); // ç¯©é¸ï¼š<= n é¡†æ˜Ÿ
        const [starModalOpen, setStarModalOpen] = useState(false);

        // åˆå§‹è¼‰å…¥ï¼šé¡Œåº« + æ˜Ÿæ˜Ÿ
        useEffect(() => {
          const saved = deserialize(localStorage.getItem(LS_KEY));
          if (saved) {
            setBank(saved.bank || []);
            setSubject(saved.subject || "å…¨éƒ¨ç§‘ç›®");
            setYear(saved.year || "å…¨éƒ¨å¹´åº¦");
            setMode(saved.mode || "practice");
          }
          const s = deserialize(localStorage.getItem(LS_STAR));
          if (s && typeof s === 'object') setStars(s);
        }, []);

        // å„²å­˜é¡Œåº«ç‹€æ…‹
        useEffect(() => {
          localStorage.setItem(LS_KEY, serialize({ bank, subject, year, mode }));
        }, [bank, subject, year, mode]);

        // å„²å­˜æ˜Ÿæ˜Ÿ
        useEffect(() => {
          localStorage.setItem(LS_STAR, serialize(stars));
        }, [stars]);

        const subjects = useMemo(() => {
          const set = new Set(bank.map((q) => (q.subject || "").toString().trim()));
          return ["å…¨éƒ¨ç§‘ç›®", ...Array.from(set).filter(Boolean)];
        }, [bank]);

        const years = useMemo(() => {
          const set = new Set(bank.map((q) => (q.year ?? "").toString().trim()));
          const arr = Array.from(set).filter(Boolean).sort((a, b) => Number(b) - Number(a));
          return ["å…¨éƒ¨å¹´åº¦", ...arr];
        }, [bank]);

        // â­ ä¾ç§‘ç›®/å¹´åº¦/æ˜Ÿæ˜Ÿç¯©é¸
        const filtered = useMemo(() => {
          return bank.filter((q) => {
            const okS = subject === "å…¨éƒ¨ç§‘ç›®" || (q.subject || "").toString().trim() === subject;
            const okY = year === "å…¨éƒ¨å¹´åº¦" || (q.year ?? "").toString().trim() === year;
            const st = Number(stars[q.id] || 0);
            const okStar = (maxStarFilter == null) || st <= maxStarFilter;
            return okS && okY && okStar;
          });
        }, [bank, subject, year, stars, maxStarFilter]);

        const paper = useMemo(() => {
          const base = shuffle(filtered.slice());
          return base.slice(0, Math.min(limit, base.length)).map((q, i) => ({ ...q, order: i + 1 }));
        }, [filtered, limit, seed]);

        useEffect(() => {
          if (!started || mode !== "exam") return;
          timerRef.current = window.setInterval(() => setSeconds((s) => s + 1), 1000);
          return () => { if (timerRef.current) window.clearInterval(timerRef.current); };
        }, [started, mode]);

        const start = () => { setAnswers({}); setPage(0); setSeed((s) => s + 1); setSeconds(0); setStarted(true); };
        const stop = () => { setStarted(false); if (timerRef.current) window.clearInterval(timerRef.current); };

        const current = paper[page];
        const choose = (qid, key) => setAnswers((prev) => ({ ...prev, [qid]: key }));
        const isCorrect = (q, user) => {
          const ok = (q.correct_answers || "").split(",").map((x) => x.trim()).filter(Boolean);
          return user ? ok.includes(user) : false;
        };

        // â­ ç­”é¡Œå¾Œè‡ªå‹•æ›´æ–°æ˜Ÿæ˜Ÿï¼šå° +1ï¼ŒéŒ¯æ­¸é›¶
        useEffect(() => {
          if (!current) return;
          const picked = answers[current.id];
          if (!picked) return;
          const correct = isCorrect(current, picked);
          setStars((prev) => {
            const cur = Number(prev[current.id] || 0);
            const next = correct ? Math.min(5, cur + 1) : 0;
            if (next === cur) return prev;
            return { ...prev, [current.id]: next };
          });
        }, [answers[current?.id]]); // é‡å°ç•¶å‰é¡Œç›®çš„ä½œç­”è®Šå‹•

        const score = useMemo(() => {
          let right = 0; paper.forEach((q) => { if (isCorrect(q, answers[q.id])) right += 1; });
          return { right, total: paper.length };
        }, [paper, answers]);

        const wrongList = useMemo(() => paper.filter((q) => !isCorrect(q, answers[q.id])), [paper, answers]);

        // é€²åº¦çµ±è¨ˆï¼ˆä»¥ã€Œæœ‰æ˜Ÿæ˜Ÿ>0 çš„é¡Œç›®ã€è¦–ç‚ºæœ‰ç·´éï¼‰
        const doneCount = useMemo(() => bank.reduce((s, q) => s + (Number(stars[q.id] || 0) > 0 ? 1 : 0), 0), [bank, stars]);
        const progressPct = bank.length ? Math.round((doneCount / bank.length) * 100) : 0;

        const onImport = (file) => {
          if (!file) { alert("å°šæœªé¸æ“‡é¡Œåº«æª”æ¡ˆ"); return; }
          const name = (file.name || "").toLowerCase();
          if (name.endsWith(".csv")) {
            PapaLib.parse(file, {
              header: true,
              skipEmptyLines: true,
              complete: (res) => {
                let ok = 0, skipped = 0;
                const rows = (res.data || []).map((raw) => {
                  const base = normalizeKeys(raw);
                  const r = { ...base };
                  r.year = r.year ?? r["å¹´åº¦"] ?? r["å¹´ä»½"] ?? r["\ufeffyear"];
                  r.subject = r.subject ?? r["ç§‘ç›®"];
                  r.question_no = r.question_no ?? r["é¡Œè™Ÿ"] ?? r["é¡Œç›®ç·¨è™Ÿ"] ?? r["no"] ?? r["\ufeffquestion_no"];
                  r.question = r.question ?? r["é¡Œç›®"] ?? r["stem"];
                  r.option_A = r.option_A ?? r["A"] ?? r["é¸é …A"];
                  r.option_B = r.option_B ?? r["B"] ?? r["é¸é …B"];
                  r.option_C = r.option_C ?? r["C"] ?? r["é¸é …C"];
                  r.option_D = r.option_D ?? r["D"] ?? r["é¸é …D"];
                  r.correct_answers = r.correct_answers ?? r["æ­£ç¢ºç­”æ¡ˆ"] ?? r["answer"];
                  r.notes = r.notes ?? r["å‚™è¨»"];
                  r.date = r.date ?? r["æ—¥æœŸ"]; r.session = r.session ?? r["å ´æ¬¡"] ?? r["session"];
                  const qa = rowToQA(r);
                  if (!qa.year || !qa.subject || !qa.question_no) { skipped += 1; return null; }
                  ok += 1; return qa;
                }).filter(Boolean);
                const dup = countDup(bank, rows);
                setBank((prev) => mergeBank(prev, rows));
                alert(`å·²åŒ¯å…¥ ${ok} é¡Œ${skipped ? `ï¼Œç•¥é ${skipped} é¡Œï¼ˆç¼ºå°‘ å¹´åº¦/ç§‘ç›®/é¡Œè™Ÿï¼‰` : ""}ï¼›å…¶ä¸­ ${dup} é¡Œèˆ‡æ—¢æœ‰é¡Œç›®ï¼ˆç›¸åŒ å¹´åº¦/æ—¥æœŸ(æˆ–å ´æ¬¡)/ç§‘ç›®/é¡Œè™Ÿï¼‰é‡è¤‡ï¼Œå·²è‡ªå‹•åˆä½µ`);
              },
            });
            return;
          }
          if (name.endsWith(".json")) {
            const reader = new FileReader();
            reader.onload = () => {
              try {
                const json = JSON.parse(reader.result);
                const arr = Array.isArray(json) ? json : json.items || [];
                let ok = 0, skipped = 0;
                const rows = arr.map((raw) => {
                  const base = normalizeKeys(raw);
                  const r = { ...base };
                  r.year = r.year ?? r["å¹´åº¦"] ?? r["å¹´ä»½"];
                  r.subject = r.subject ?? r["ç§‘ç›®"];
                  r.question_no = r.question_no ?? r["é¡Œè™Ÿ"] ?? r["é¡Œç›®ç·¨è™Ÿ"] ?? r["no"];
                  r.question = r.question ?? r["é¡Œç›®"] ?? r["stem"];
                  r.option_A = r.option_A ?? r["A"] ?? r["é¸é …A"];
                  r.option_B = r.option_B ?? r["B"] ?? r["é¸é …B"];
                  r.option_C = r.option_C ?? r["C"] ?? r["é¸é …C"];
                  r.option_D = r.option_D ?? r["D"] ?? r["é¸é …D"];
                  r.correct_answers = r.correct_answers ?? r["æ­£ç¢ºç­”æ¡ˆ"] ?? r["answer"];
                  r.notes = r.notes ?? r["å‚™è¨»"];
                  r.date = r.date ?? r["æ—¥æœŸ"];
                  const qa = rowToQA(r);
                  if (!qa.year || !qa.subject || !qa.question_no) { skipped += 1; return null; }
                  ok += 1; return qa;
                }).filter(Boolean);
                const dup = countDup(bank, rows);
                setBank((prev) => mergeBank(prev, rows));
                alert(`å·²åŒ¯å…¥ ${ok} é¡Œ${skipped ? `ï¼Œç•¥é ${skipped} é¡Œï¼ˆç¼ºå°‘ å¹´åº¦/ç§‘ç›®/é¡Œè™Ÿï¼‰` : ""}ï¼›å…¶ä¸­ ${dup} é¡Œèˆ‡æ—¢æœ‰é¡Œç›®ï¼ˆç›¸åŒ å¹´åº¦/æ—¥æœŸ(æˆ–å ´æ¬¡)/ç§‘ç›®/é¡Œè™Ÿï¼‰é‡è¤‡ï¼Œå·²è‡ªå‹•åˆä½µ`);
              } catch { alert("JSON è§£æå¤±æ•—"); }
            };
            reader.readAsText(file, "utf-8");
            return;
          }
          alert("è«‹ä¸Šå‚³ CSV æˆ– JSON æª”");
        };

        const onImportCorrections = (file) => {
          if (!file) { alert("å°šæœªé¸æ“‡æ›´æ­£/çµ¦åˆ†è¡¨æª”æ¡ˆ"); return; }
          PapaLib.parse(file, {
            header: true,
            skipEmptyLines: true,
            complete: (res) => {
              try {
                const rows = (res.data || []).map((raw) => {
                  const r = normalizeKeys(raw);
                  return {
                    å¹´åº¦: String(pick(r, ["å¹´åº¦", "year"]) ?? ""),
                    å ´æ¬¡: String(pick(r, ["å ´æ¬¡", "session"]) ?? ""),
                    ç§‘ç›®: String(pick(r, ["ç§‘ç›®", "subject"]) ?? ""),
                    é¡Œè™Ÿ: Number(String(pick(r, ["é¡Œè™Ÿ", "question_no", "no"]) ?? "").replace(/[^0-9.-]/g, "")),
                    æ­£ç¢ºç­”æ¡ˆ: String(pick(r, ["æ­£ç¢ºç­”æ¡ˆ", "correct_answers"]) ?? ""),
                  };
                });
                const valid = rows.filter((r) => r.å¹´åº¦ && r.ç§‘ç›® && Number.isFinite(r.é¡Œè™Ÿ) && r.æ­£ç¢ºç­”æ¡ˆ);
                setCorrections(valid);
                alert(`å·²åŒ¯å…¥æ›´æ­£ ${valid.length} ç­†`);
              } catch (e) { console.error(e); alert("æ›´æ­£ CSV è§£æå¤±æ•—"); }
            },
          });
        };

        const toRawUrl = (u) => {
          try {
            if (!u) return "";
            if (/^gh:/i.test(u)) {
              const m = u.replace(/^gh:/i, "").match(/^([^\/]+)\/([^@]+)@([^:]+):(.+)$/);
              if (m) { const [, user, repo, branch, path] = m; return `https://raw.githubusercontent.com/${user}/${repo}/${branch}/${path}`; }
              return u;
            }
            if (/^https?:\/\/github\.com\/.+\/blob\//.test(u)) {
              return u.replace(/^https?:\/\/github\.com\//, "https://raw.githubusercontent.com/").replace("/blob/", "/");
            }
            return u;
          } catch { return u; }
        };

        const onImportUrl = (url) => {
          const u = toRawUrl(url.trim());
          if (!u) { alert("è«‹è¼¸å…¥é¡Œåº«ç¶²å€"); return; }
          if (/\.csv(?:$|\?)/i.test(u)) {
            PapaLib.parse(u, {
              download: true,
              header: true,
              skipEmptyLines: true,
              complete: (res) => {
                let ok = 0, skipped = 0;
                const rows = (res.data || []).map((raw) => {
                  const base = normalizeKeys(raw);
                  const r = { ...base };
                  r.year = r.year ?? r["å¹´åº¦"] ?? r["å¹´ä»½"] ?? r["ï»¿year"];
                  r.subject = r.subject ?? r["ç§‘ç›®"];
                  r.question_no = r.question_no ?? r["é¡Œè™Ÿ"] ?? r["é¡Œç›®ç·¨è™Ÿ"] ?? r["no"] ?? r["ï»¿question_no"];
                  r.question = r.question ?? r["é¡Œç›®"] ?? r["stem"];
                  r.option_A = r.option_A ?? r["A"] ?? r["é¸é …A"];
                  r.option_B = r.option_B ?? r["B"] ?? r["é¸é …B"];
                  r.option_C = r.option_C ?? r["C"] ?? r["é¸é …C"];
                  r.option_D = r.option_D ?? r["D"] ?? r["é¸é …D"];
                  r.correct_answers = r.correct_answers ?? r["æ­£ç¢ºç­”æ¡ˆ"] ?? r["answer"];
                  r.notes = r.notes ?? r["å‚™è¨»"];
                  r.date = r.date ?? r["æ—¥æœŸ"];
                  r.session = r.session ?? r["å ´æ¬¡"] ?? r["session"];
                  const qa = rowToQA(r);
                  if (!qa.year || !qa.subject || !qa.question_no) { skipped += 1; return null; }
                  ok += 1; return qa;
                }).filter(Boolean);
                const dup = countDup(bank, rows);
                setBank((prev) => mergeBank(prev, rows));
                alert(`å·²å¾ç¶²å€åŒ¯å…¥ ${ok} é¡Œ${skipped ? `ï¼Œç•¥é ${skipped} é¡Œï¼ˆç¼ºå°‘ å¹´åº¦/ç§‘ç›®/é¡Œè™Ÿï¼‰` : ""}ï¼›å…¶ä¸­ ${dup} é¡Œèˆ‡æ—¢æœ‰é¡Œç›®é‡è¤‡ï¼Œå·²è‡ªå‹•åˆä½µ`);
              },
              error: () => alert("ä¸‹è¼‰ CSV å¤±æ•—ï¼Œè«‹ç¢ºèªç¶²å€å¯å…¬é–‹å­˜å–"),
            });
          } else if (/\.json(?:$|\?)/i.test(u)) {
            fetch(u, { cache: "no-store" })
              .then((r) => { if (!r.ok) throw new Error("HTTP " + r.status); return r.json(); })
              .then((json) => {
                const arr = Array.isArray(json) ? json : json.items || [];
                let ok = 0, skipped = 0;
                const rows = arr.map((raw) => {
                  const base = normalizeKeys(raw);
                  const r = { ...base };
                  r.year = r.year ?? r["å¹´åº¦"] ?? r["å¹´ä»½"];
                  r.subject = r.subject ?? r["ç§‘ç›®"];
                  r.question_no = r.question_no ?? r["é¡Œè™Ÿ"] ?? r["é¡Œç›®ç·¨è™Ÿ"] ?? r["no"];
                  r.question = r.question ?? r["é¡Œç›®"] ?? r["stem"];
                  r.option_A = r.option_A ?? r["A"] ?? r["é¸é …A"];
                  r.option_B = r.option_B ?? r["B"] ?? r["é¸é …B"];
                  r.option_C = r.option_C ?? r["C"] ?? r["é¸é …C"];
                  r.option_D = r.option_D ?? r["D"] ?? r["é¸é …D"];
                  r.correct_answers = r.correct_answers ?? r["æ­£ç¢ºç­”æ¡ˆ"] ?? r["answer"];
                  r.notes = r.notes ?? r["å‚™è¨»"];
                  r.date = r.date ?? r["æ—¥æœŸ"];
                  r.session = r.session ?? r["å ´æ¬¡"] ?? r["session"];
                  const qa = rowToQA(r);
                  if (!qa.year || !qa.subject || !qa.question_no) { skipped += 1; return null; }
                  ok += 1; return qa;
                }).filter(Boolean);
                const dup = countDup(bank, rows);
                setBank((prev) => mergeBank(prev, rows));
                alert(`å·²å¾ç¶²å€åŒ¯å…¥ ${ok} é¡Œ${skipped ? `ï¼Œç•¥é ${skipped} é¡Œï¼ˆç¼ºå°‘ å¹´åº¦/ç§‘ç›®/é¡Œè™Ÿï¼‰` : ""}ï¼›å…¶ä¸­ ${dup} é¡Œèˆ‡æ—¢æœ‰é¡Œç›®é‡è¤‡ï¼Œå·²è‡ªå‹•åˆä½µ`);
              })
              .catch(() => alert("ä¸‹è¼‰ JSON å¤±æ•—ï¼Œè«‹ç¢ºèªç¶²å€å¯å…¬é–‹å­˜å–"));
          } else {
            alert("è«‹æä¾› .csv æˆ– .json é€£çµï¼ˆå»ºè­°ä½¿ç”¨ GitHub çš„ Raw é€£çµæˆ– gh: åˆ¥åï¼‰");
          }
        };

        // ç”±ç¶²å€è¼‰å…¥æ›´æ­£/çµ¦åˆ†è¡¨ï¼ˆæ”¯æ´ GitHub blob é€£çµèˆ‡ gh: åˆ¥åï¼‰
        const onImportCorrectionsUrl = (url) => {
          const u = toRawUrl(url.trim());
          if (!u) { alert("è«‹è¼¸å…¥æ›´æ­£/çµ¦åˆ†è¡¨ç¶²å€"); return; }
          PapaLib.parse(u, {
            download: true,
            header: true,
            skipEmptyLines: true,
            complete: (res) => {
              try {
                const rows = (res.data || []).map((raw) => {
                  const r = normalizeKeys(raw);
                  return {
                    å¹´åº¦: String(pick(r, ["å¹´åº¦", "year"]) ?? ""),
                    å ´æ¬¡: String(pick(r, ["å ´æ¬¡", "session"]) ?? ""),
                    ç§‘ç›®: String(pick(r, ["ç§‘ç›®", "subject"]) ?? ""),
                    é¡Œè™Ÿ: Number(String(pick(r, ["é¡Œè™Ÿ", "question_no", "no"]) ?? "").replace(/[^0-9.-]/g, "")),
                    æ­£ç¢ºç­”æ¡ˆ: String(pick(r, ["æ­£ç¢ºç­”æ¡ˆ", "correct_answers"]) ?? ""),
                  };
                });
                const valid = rows.filter((r) => r.å¹´åº¦ && r.ç§‘ç›® && Number.isFinite(r.é¡Œè™Ÿ) && r.æ­£ç¢ºç­”æ¡ˆ);
                setCorrections(valid);
                alert(`å·²å¾ç¶²å€åŒ¯å…¥æ›´æ­£ ${valid.length} ç­†`);
              } catch (e) { console.error(e); alert("æ›´æ­£ CSV è§£æå¤±æ•—"); }
            },
            error: () => alert("ä¸‹è¼‰æ›´æ­£ CSV å¤±æ•—ï¼Œè«‹ç¢ºèªç¶²å€å¯å…¬é–‹å­˜å–"),
          });
        };

        // ä¸€éµï¼šè¼‰å…¥ GitHub é¡Œåº« + æ›´æ­£è¡¨ï¼Œä¸¦è‡ªå‹•å¥—ç”¨æ›´æ­£
        const loadGithubDefaults = () => {
          const defaultBank = bankUrl || "gh:yokuhei-ping/Health-Food-Engineer-Entry@b18caf88dce70271f4e51f25c0931fa0efbbed39:Question_All_corrected.csv";
          const defaultCorr = corrUrl || "https://github.com/PingYangtw/Health-Food-Engineer-Entry/blob/2e123d2ca94719de803cd8766b22256a37630c58/exam_corrections_all_years.csv";
          onImportUrl(defaultBank);
          onImportCorrectionsUrl(defaultCorr);
          setTimeout(() => { try { applyCorrections(); } catch (e) {} }, 800);
        };

        const handleImportChange = (e) => {
          const file = e.target.files?.[0] ?? null;
          if (!file) { alert("å°šæœªé¸æ“‡é¡Œåº«æª”æ¡ˆ"); return; }
          onImport(file);
          e.target.value = "";
        };
        const handleCorrectionsChange = (e) => {
          const file = e.target.files?.[0] ?? null;
          if (!file) { alert("å°šæœªé¸æ“‡æ›´æ­£/çµ¦åˆ†è¡¨æª”æ¡ˆ"); return; }
          onImportCorrections(file);
          e.target.value = "";
        };

        const applyCorrections = () => {
          if (!corrections.length) { alert("å°šæœªåŒ¯å…¥æ›´æ­£è¡¨"); return; }
          setBank((prev) => {
            const next = applyCorrectionsToBank(prev, corrections);
            alert("å·²å°‡æ›´æ­£å¥—ç”¨åˆ°é¡Œåº«ï¼ˆåŒé¡Œè¦†è“‹ correct_answersï¼‰");
            return next;
          });
        };

        const mergeBank = (prev, rows) => {
          const map = new Map(prev.map((q) => [q.id, q]));
          for (const r of rows) map.set(r.id, r);
          return Array.from(map.values());
        };

        const countDup = (prev, rows) => {
          const set = new Set(prev.map((q) => q.id));
          let dup = 0; for (const r of rows) if (set.has(r.id)) dup += 1;
          return dup;
        };

        const exportWrong = () => {
          if (!wrongList.length) { alert("ç›®å‰æ²’æœ‰å¯åŒ¯å‡ºçš„éŒ¯é¡Œï¼ˆè«‹å…ˆé–‹å§‹ä½œç­”ä¸¦ç”¢ç”ŸéŒ¯é¡Œï¼‰"); return; }
          const rows = wrongList.map((q) => ({
            year: q.year, subject: q.subject, question_no: q.question_no, question: q.question,
            option_A: q.option_A, option_B: q.option_B, option_C: q.option_C, option_D: q.option_D,
            correct_answers: q.correct_answers, notes: q.notes,
          }));
          try { exportCSV(rows, "éŒ¯é¡Œæœ¬.csv"); alert(`å·²åŒ¯å‡º ${rows.length} é¡ŒéŒ¯é¡Œè‡³ã€ŒéŒ¯é¡Œæœ¬.csvã€`); }
          catch (e) { console.error(e); alert("ä¸‹è¼‰å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç€è¦½å™¨ä¸‹è¼‰æ¬Šé™æˆ–æ”¹ç”¨ã€ŒåŒ¯å‡ºç›®å‰é¡Œåº« CSVã€"); }
        };

        const exportAll = () => {
          const rows = bank.map((q) => ({
            year: q.year, date: q.date, subject: q.subject, question_no: q.question_no, question: q.question,
            option_A: q.option_A, option_B: q.option_B, option_C: q.option_C, option_D: q.option_D,
            correct_answers: q.correct_answers, notes: q.notes,
          }));
          exportCSV(rows, "Question_All (1).csv");
        };

        const loadSamples = () => { const rows = SAMPLE_ROWS.map(rowToQA); setBank((prev) => mergeBank(prev, rows)); alert(`å·²è¼‰å…¥ç¯„ä¾‹ ${rows.length} é¡Œ`); };

        const clearBank = () => {
          const ok = typeof window !== "undefined" && typeof window.confirm === "function" ? window.confirm("ç¢ºå®šè¦æ¸…ç©ºç›®å‰é¡Œåº«å—ï¼Ÿï¼ˆå°‡åŒæ™‚åˆªé™¤æœ¬åœ°å¿«å–ï¼‰") : true;
          if (!ok) return;
          setBank([]); setAnswers({}); setStarted(false); setPage(0); setSeed((s) => s + 1);
          try { localStorage.removeItem(LS_KEY); } catch (e) { console.warn("ç„¡æ³•å­˜å– localStorageï¼š", e); }
          alert("é¡Œåº«èˆ‡å¿«å–å·²æ¸…ç©º");
        };

        // â­ æ˜Ÿæ˜Ÿç›¸é—œï¼šé‡ç½®ã€é–‹å½ˆçª—ã€å¥—ç”¨ç¯©é¸
        const resetStars = () => {
          const ok = window.confirm('ç¢ºå®šè¦å°‡æ‰€æœ‰é¡Œç›®çš„æ˜Ÿæ˜Ÿç†Ÿæ‚‰åº¦æ­¸é›¶å—ï¼Ÿ');
          if (!ok) return;
          setStars({});
          alert('å·²é‡ç½®æ˜Ÿæ˜Ÿç†Ÿæ‚‰åº¦');
        };

        const eligibleCount = (maxN) => bank.reduce((s, q) => s + ((Number(stars[q.id] || 0) <= maxN) ? 1 : 0), 0);

        return (
          <div className="min-h-screen bg-gray-50 text-gray-800 p-6">
            <header className="max-w-5xl mx-auto mb-4">
              <h1 className="text-2xl sm:text-3xl font-bold">ä¿å¥é£Ÿå“åˆç´šå·¥ç¨‹å¸«ï½œæ­·å±†è©¦é¡Œç·šä¸Šç·´ç¿’</h1>
              <p className="text-sm text-gray-600 mt-1">åŒ¯å…¥æ­·å±† CSV/JSON é¡Œåº« or å¾ç¶²å€è¼‰å…¥ â†’ ç¯©é¸ç§‘ç›®/å¹´åº¦ â†’ ç·´ç¿’/æ¨¡æ“¬è€ƒï¼ˆæ”¯æ´å¤šç­”æ¡ˆçµ¦åˆ†ã€éŒ¯é¡Œæœ¬èˆ‡åŒ¯å‡ºï¼‰</p>
            </header>

            <main className="max-w-5xl mx-auto grid gap-4">
              <section className="bg-white rounded-2xl shadow p-4 grid gap-3">
                <div className="flex flex-wrap items-center gap-3">
                  <label className="text-sm">ç§‘ç›®</label>
                  <select className="border rounded-xl px-3 py-2" value={subject} onChange={(e) => setSubject(e.target.value)}>
                    {subjects.map((s) => (<option key={s} value={s}>{s}</option>))}
                  </select>

                  <label className="text-sm ml-2">å¹´åº¦</label>
                  <select className="border rounded-xl px-3 py-2" value={year} onChange={(e) => setYear(e.target.value)}>
                    {years.map((y) => (<option key={y} value={y}>{y}</option>))}
                  </select>

                  <label className="text-sm ml-2">æ¨¡å¼</label>
                  <select className="border rounded-xl px-3 py-2" value={mode} onChange={(e) => setMode(e.target.value)}>
                    <option value="practice">ç·´ç¿’ï¼ˆå³æ™‚å°ç­”æ¡ˆï¼‰</option>
                    <option value="exam">æ¨¡æ“¬è€ƒï¼ˆäº¤å·å¾Œæ­æ›‰ï¼‰</option>
                  </select>

                  <label className="text-sm ml-2">é¡Œæ•¸</label>
                  <input className="border rounded-xl px-3 py-2 w-24" type="number" min={1} max={200} value={limit} onChange={(e) => setLimit(Number(e.target.value || 1))} />

                  <label className="text-sm ml-2">åŒ¯å…¥é¡Œåº«</label>
                  <input className="border rounded-xl px-3 py-2" type="file" accept=".csv,.json" onChange={handleImportChange} />
                  <input className="border rounded-xl px-3 py-2 w-64" type="url" placeholder="è²¼ä¸Šé¡Œåº« CSV/JSON ç¶²å€æˆ– gh:åˆ¥å" value={bankUrl} onChange={(e)=>setBankUrl(e.target.value)} />
                  <button className="rounded-2xl px-4 py-2 border" onClick={()=>onImportUrl(bankUrl)}>å¾ç¶²å€è¼‰å…¥</button>

                  <button className="ml-auto rounded-2xl px-4 py-2 bg-gray-900 text-white hover:opacity-90" onClick={start}>é–‹å§‹ä½œç­”</button>
                  {started && (<button className="rounded-2xl px-4 py-2 border" onClick={stop}>çµæŸ/äº¤å·</button>)}
                </div>
                <div className="flex gap-2 flex-wrap text-sm">
                  <button className="rounded-xl px-3 py-2 border" onClick={exportWrong}>åŒ¯å‡ºéŒ¯é¡Œæœ¬ CSV</button>
                  <button className="rounded-xl px-3 py-2 border" onClick={clearBank}>æ¸…ç©ºé¡Œåº«</button>
                  {/* â­ ä¾æ˜Ÿæ˜Ÿæ•¸é‡æ¸¬é©— / é‡ç½®æ˜Ÿæ˜Ÿ / æ¸…é™¤æ˜Ÿæ˜Ÿç¯©é¸ */}
                  <button className="rounded-xl px-3 py-2 border" onClick={()=>setStarModalOpen(true)}>ä¾æ˜Ÿæ˜Ÿæ•¸é‡æ¸¬é©—</button>
                  <button className="rounded-xl px-3 py-2 border" onClick={resetStars}>é‡ç½®æ˜Ÿæ˜Ÿæ•¸é‡</button>
                  <button className="rounded-xl px-3 py-2 border" onClick={()=>setMaxStarFilter(null)}>æ¸…é™¤æ˜Ÿæ˜Ÿç¯©é¸</button>
                </div>
                <div className="text-sm text-gray-600">ç›®å‰é¡Œåº«ï¼š{filtered.length} é¡Œï¼ˆç¬¦åˆç¯©é¸ï¼‰ï¼ å…¨éƒ¨ {bank.length} é¡Œ</div>
                <div className="text-xs text-gray-500">å”¯ä¸€éµï¼šå¹´-æ—¥æœŸ(æˆ–å ´æ¬¡)-ç§‘ç›®-é¡Œè™Ÿï¼ˆé¿å…ä¸åŒå ´æ¬¡åŒé¡Œè™Ÿè¢«åˆä½µï¼‰</div>
                {/* â­ é€²åº¦ç™¾åˆ†æ¯” */}
                <div className="text-xs text-amber-600 flex items-center gap-2">
                  <StarBar value={5} size={14}/> <span>ç·´ç¿’é€²åº¦ï¼š{progressPct}%ï¼ˆ{doneCount}/{bank.length || 0}ï¼‰</span>
                  {maxStarFilter!=null && <span className="ml-2 px-2 py-0.5 rounded-full bg-amber-50 border text-amber-700">æ˜Ÿæ˜Ÿç¯©é¸ï¼šâ‰¤ {maxStarFilter} â˜…</span>}
                </div>
              </section>

              {started && current && (
                <section className="bg-white rounded-2xl shadow p-5">
                  <div className="flex items-start gap-3 flex-wrap">
                    <div className="text-xs px-2 py-1 rounded-full bg-gray-100">{mode === "exam" ? "æ¨¡æ“¬è€ƒ" : "ç·´ç¿’"}</div>
                    <div className="text-xs px-2 py-1 rounded-full bg-gray-100">{current.subject || "â€”"}</div>
                    <div className="text-xs px-2 py-1 rounded-full bg-gray-100">{current.year || "â€”"} å¹´</div>
                    <div className="text-xs px-2 py-1 rounded-full bg-gray-100">é¡Œè™Ÿï¼š{current.question_no}</div>
                    <div className="text-xs px-2 py-1 rounded-full bg-gray-100">ç¬¬ {page + 1} / {paper.length} é¡Œ</div>
                    {mode === "exam" && <div className="text-xs px-2 py-1 rounded-full bg-gray-100">è¨ˆæ™‚ï¼š{fmtTime(seconds)}</div>}
                    {/* â­ æ­¤é¡Œç›®å‰æ˜Ÿæ˜Ÿæ•¸ */}
                    <div className="text-xs px-2 py-1 rounded-full bg-amber-50 border text-amber-700 flex items-center gap-1">
                      <span>ç†Ÿæ‚‰åº¦</span><StarBar value={stars[current.id]||0} size={14}/><span>{Number(stars[current.id]||0)}â˜…</span>
                    </div>
                  </div>

                  <h2 className="mt-3 text-lg font-semibold leading-relaxed whitespace-pre-wrap">{current.question}</h2>

                  <ul className="mt-4 grid gap-2">
                    {current.options?.map((op) => {
                      const picked = answers[current.id] === op.key;
                      const showAnswer = mode === "practice" && picked;
                      const correctSet = (current.correct_answers || "").split(",").map((x) => x.trim());
                      const isRight = correctSet.includes(op.key);
                      const className = [
                        "w-full text-left border rounded-xl p-3 hover:bg-gray-50",
                        picked && showAnswer && (isRight ? "border-green-500 bg-green-50" : "border-red-400 bg-red-50"),
                      ].join(" ");
                      return (
                        <li key={op.key}>
                          <button className={className} onClick={() => choose(current.id, op.key)}>
                            <span className="font-mono mr-2">({op.key})</span>
                            <span className="whitespace-pre-wrap">{op.text || "â€”"}</span>
                          </button>
                        </li>
                      );
                    })}
                  </ul>

                  {mode === "practice" && (
                    <div className="mt-4 text-sm">
                      {answers[current.id] ? (
                        isCorrect(current, answers[current.id]) ? (
                          <div className="text-green-700">âœ” æ­å–œç­”å°ï¼å¯æ¥å—ç­”æ¡ˆï¼š{current.correct_answers}</div>
                        ) : (
                          <div className="text-red-700">âœ˜ ç­”éŒ¯äº†ï¼Œæ­£è§£ï¼š{current.correct_answers}</div>
                        )
                      ) : (
                        <div className="text-gray-500">è«‹é¸æ“‡ä¸€å€‹é¸é …ä½œç­”</div>
                      )}
                      {current.notes && <div className="mt-1 text-gray-600">å‚™è¨»ï¼š{current.notes}</div>}
                    </div>
                  )}

                  <div className="mt-5 flex gap-2">
                    <button className="rounded-xl px-4 py-2 border" disabled={page === 0} onClick={() => setPage((p) => Math.max(0, p - 1))}>ä¸Šä¸€é¡Œ</button>
                    <button className="rounded-xl px-4 py-2 border" disabled={page >= paper.length - 1} onClick={() => setPage((p) => Math.min(paper.length - 1, p + 1))}>ä¸‹ä¸€é¡Œ</button>
                    <button className="rounded-xl px-4 py-2 border ml-auto" onClick={() => setPage(0)}>å›åˆ°ç¬¬ 1 é¡Œ</button>
                  </div>
                </section>
              )}

              {started && (
                <section className="bg-white rounded-2xl shadow p-5 grid gap-3">
                  <div className="text-sm">ä½œç­”é€²åº¦ï¼š{Object.keys(answers).length}/{paper.length} é¡Œ</div>
                  <div className="text-lg">ç›®å‰çµ±è¨ˆï¼š<span className="font-semibold">{score.right}</span> / {score.total} é¡Œ æ­£ç¢º</div>
                  <div className="flex gap-2 flex-wrap">
                    <button className="rounded-xl px-4 py-2 bg-gray-900 text-white" onClick={stop}>çµæŸ / äº¤å·</button>
                    <button className="rounded-xl px-4 py-2 border" onClick={() => setSeed((s) => s + 1)}>é‡æŠ½é¡Œç›®</button>
                    <button className="rounded-xl px-4 py-2 border" onClick={exportWrong}>åŒ¯å‡ºéŒ¯é¡Œæœ¬ CSV</button>
                  </div>
                  {!!wrongList.length && (<div className="text-sm text-gray-600">ç›®å‰éŒ¯é¡Œï¼š{wrongList.length} é¡Œï¼ˆå¯ç”¨ä¸Šæ–¹æŒ‰éˆ•åŒ¯å‡º CSV ç•¶éŒ¯é¡Œæœ¬ï¼‰</div>)}
                </section>
              )}

              {!bank.length && (
                <section className="bg-white rounded-2xl shadow p-6">
                  <h3 className="text-lg font-semibold mb-2">ğŸ‘‹ å…ˆè¼‰å…¥é¡Œåº«å¾Œé–‹å§‹ä½¿ç”¨</h3>
                  <ol className="list-decimal pl-6 space-y-2 text-sm text-gray-700">
                    <li>é»ä¸Šæ–¹ <b>åŒ¯å…¥é¡Œåº«</b>ï¼Œä¸Šå‚³ CSV æˆ– JSONã€‚</li>
                    <li>æˆ–é» <b>å¾ç¶²å€è¼‰å…¥</b> ç«‹å³é«”é©—ï¼ˆå«å¤šç­”æ¡ˆçš†çµ¦åˆ†ï¼‰ã€‚</li>
                    <li>CSV æ¬„ä½ï¼š<code>year, date, subject, question_no, question, option_A, option_B, option_C, option_D, correct_answers, notes</code></li>
                    <li>å¤šå€‹å¯æ¥å—ç­”æ¡ˆè«‹ä»¥é€—è™Ÿåˆ†éš”ï¼Œå¦‚ <code>"A,B,C"</code>ã€‚</li>
                  </ol>
                </section>
              )}
            </main>

            <footer className="max-w-5xl mx-auto py-8 text-center text-xs text-gray-400">Â© ç·´ç¿’åŸå‹</footer>

            {/* â­ ä¾æ˜Ÿæ˜Ÿæ•¸é‡æ¸¬é©—å½ˆçª— */}
            {starModalOpen && (
              <div className="fixed inset-0 z-50 flex items-center justify-center">
                <div className="absolute inset-0 bg-black/40" onClick={()=>setStarModalOpen(false)}></div>
                <div className="relative bg-white rounded-2xl shadow-xl p-4 w-[90%] max-w-md">
                  <div className="flex items-center justify-between">
                    <h3 className="text-lg font-semibold">ä¾ç…§æ˜Ÿæ˜Ÿæ•¸é‡æ¸¬é©—</h3>
                    <div className="text-xs text-amber-600 flex items-center gap-1"><StarBar value={5} size={14}/><span>{progressPct}%</span><span className="text-gray-400">{doneCount}/{bank.length}</span></div>
                  </div>
                  <ul className="mt-3 divide-y">
                    {[0,1,2,3,4].map((n)=> (
                      <li key={n}>
                        <button className="w-full flex items-center justify-between py-3 hover:bg-gray-50" onClick={()=>{setMaxStarFilter(n); setStarModalOpen(false); start();}}>
                          <div className="flex items-center gap-2">
                            <div className="flex">
                              {Array.from({length:5}).map((_,i)=> (
                                <svg key={i} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="18" height="18"
                                  className={i < (n+1) ? "fill-yellow-400 text-yellow-400" : "fill-none text-gray-300"} stroke="currentColor" strokeWidth="2">
                                  <path d="M12 17.27 18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/>
                                </svg>
                              ))}
                            </div>
                            <span className="text-sm">æ¸¬é©— 0 ~ {n} é¡†æ˜Ÿçš„é¡Œç›®</span>
                          </div>
                          <span className="text-sm text-gray-500">{eligibleCount(n)} é¡Œ</span>
                        </button>
                      </li>
                    ))}
                  </ul>
                  <p className="mt-2 text-xs text-gray-500 leading-relaxed">æ˜Ÿæ˜Ÿæ•¸é‡ä»£è¡¨å°é¡Œç›®çš„ç†Ÿæ‚‰åº¦ï¼šç­”å° +1ï¼ˆæœ€å¤š 5 é¡†ï¼‰ï¼Œç­”éŒ¯æ­¸é›¶ã€‚å¯ç”¨æ­¤åŠŸèƒ½é‡å°ä¸ç†Ÿçš„é¡Œç›®å¤šç·´ç¿’ã€‚</p>
                  <div className="mt-3 flex gap-2">
                    <button className="rounded-xl px-3 py-2 border" onClick={()=>setStarModalOpen(false)}>é—œé–‰</button>
                    <button className="rounded-xl px-3 py-2 border" onClick={()=>{setMaxStarFilter(null); setStarModalOpen(false);}}>æ¸…é™¤æ˜Ÿæ˜Ÿç¯©é¸</button>
                    <button className="rounded-xl px-3 py-2 border" onClick={resetStars}>é‡ç½®æ˜Ÿæ˜Ÿæ•¸é‡</button>
                  </div>
                </div>
              </div>
            )}
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
